////////////// Enemy entities /////////////////////////////////////// enemy1// enemy1 walks from left to right & right to leftgame.enemy_hor_entity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/		this.parent(x, y, settings);		this.walkLeft = true;				// used to determine if walking left		this.startX = x;					// original pos.x		this.endX = x + settings.width - settings.spritewidth;	// end of path				this.setVelocity(3, 12);			// speed		this.collidable = true;		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type				this.alwaysUpdate = true;		this.updateColRect(-1, 0, -1, 0);		},	onCollision : function(res, obj) {		var weapon = me.game.getEntityByName("weapon")[0];		// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			if (this.alive &&  (obj.name == "weapon" )) {				me.game.remove(this);			}		}else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {		// determing if being jumped on by boyEntity or girlEntity				me.game.remove(this);			}	},	update : function() {			if (this.walkLeft && this.pos.x <= this.startX) {			this.walkLeft = false;		} else if (!this.walkLeft && this.pos.x >= this.endX) {			this.walkLeft = true;		}				this.flipX(this.walkLeft);		this.vel.x += (this.walkLeft) ? -this.accel.x * me.timer.tick : this.accel.x * me.timer.tick;				// check and update movement (MelonJS)		this.updateMovement();				// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	}});// enemy  that moves in a square path and will not be killedgame.enemy_squ_path_entity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/			this.parent(x, y, settings);		this.startX = x;			// start pos.x		this.startY = y;			// start pos.y								this.X2 = x + settings.width - settings.spritewidth;		// other x corrdinate we want to check for		this.Y2 = y + settings.height - settings.spriteheight;		// other y corrdinate we want to check for		this.setVelocity(2, 2);		// speed		this.gravity = 0;			// so it can fly				this.collidable = true;		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type		this.alwaysUpdate = true;		this.updateColRect(-1,0,-1,0);		},	onCollision : function(res, obj) {		var weapon = me.game.getEntityByName("weapon")[0];				// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon"))) {				this.renderable.flicker(45);			}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);			}		},	update : function() {				if (this.renderable.isFlickering()){			this.setVelocity(0, 0);				}else{			this.setVelocity(2,2);		}		// what we want to constantly be updated		this.updateMovement();		this.squarePath();		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	},	squarePath : function() {		if (((this.pos.y == this.startY) || (this.pos.y < this.startY)) && !(this.pos.x > this.X2)) {			// moving right			this.vel.y = 0;			this.vel.x += this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.X2) || (this.pos.x > this.X2)) && !(this.pos.y > this.Y2)) {			// moving down			this.vel.x = 0;			this.vel.y += this.accel.y * me.timer.tick;		}else if (((this.pos.y == this.Y2) || (this.pos.y > this.Y2)) && !(this.pos.x < this.startX)) {			// moving right			this.vel.y = 0;			this.vel.x -= this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.startX) || (this.pos.x < this.startX)) && !(this.pos.y < this.startY)) {			// moving up			this.vel.x = 0;			this.vel.y -= this.accel.y * me.timer.tick;		}	},});game.enemy_up_down_entity = me.ObjectEntity.extend({ // gear     init: function(x, y, settings) { // a constructor        // call the constructor        this.parent(x, y, settings);        this.updateColRect(-1,0,-1,0); 		this.walkLeft = true; 		this.startY = y; 		this.endY = y + settings.height - settings.spriteheight; 	        this.setVelocity(0, 2); 		this.collidable = true;  		this.type = me.game.ENEMY_OBJECT; 		this.alwaysUpdate = true; // moving even out of scope 		this.key = "gear";  	    },     update: function() {  			 		if(this.walkLeft && this.pos.y <= this.startY){ // walkleft ---> walkUp 			this.walkLeft = false; 		} 		else if(!this.walkLeft && this.pos.y >= this.endY){  			this.walkLeft = true; 		} 			 		this.vel.y += (this.walkLeft) ? -this.maxVel.y * me.timer.tick : this.maxVel.y * me.timer.tick; 		// check and update movement 		this.updateMovement(); 		 		// update animation if necessary 		if(this.vel.x!=0 || this.vel.y!=0){ 			// update object animation 			this.parent(); 			return true; 		} 		return false; 	}, 	});